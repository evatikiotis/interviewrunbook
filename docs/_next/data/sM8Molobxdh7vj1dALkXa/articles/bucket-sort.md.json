{"pageProps":{"article":"# ðŸª£ Bucket Sort Algorithm ðŸª£\n\nBucket Sort is a comparison sort algorithm that distributes elements into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm or by recursively applying the bucket sort. After sorting each bucket, the elements are concatenated to form the final sorted array.\n\nWe needed Bucket Sort to effectively solve the [Top K frequent elements problem](https://leetcode.com/problems/top-k-frequent-elements)\n\nMore specifically we \n* calculated the frequency of each element | O(n)\n* initialize frequency buckets | O(n)\n* collect the top k frequent elements | k\n\n\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        // calculate frequency of each element\n        Map<Integer, Integer> freq = new HashMap<>();\n        for (int num : nums) {\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n        // initialize frequency buckets\n        List<Integer>[] frequencyBuckets = new List[nums.length + 1];\n        for(int num : freq.keySet()) {\n            Integer frequency = freq.get(num);\n            List<Integer> frequencyBucket = frequencyBuckets[frequency];\n            if(frequencyBucket == null) {\n                frequencyBuckets[frequency] = new ArrayList<>(List.of(num));\n            } else {\n                frequencyBuckets[frequency].add(num);\n            }\n        }\n        // collect the top k frequent elements\n        int[] answer = new int[k];\n        int pos = k - 1;\n        int index = frequencyBuckets.length - 1;\n        do{\n\n            if(frequencyBuckets[index] != null) {\n                for (Integer num : frequencyBuckets[index]) {\n                    answer[pos] = num;\n                    pos--;\n                }\n            }\n            index--;\n        } while (pos >= 0);\n\n        return answer;\n    }\n}\n```"},"__N_SSG":true}